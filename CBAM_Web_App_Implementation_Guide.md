# CBAM Web Application Implementation Guide

## Overview

This guide provides a comprehensive, step-by-step process to ensure the CBAM web application's functionality is identical to the Excel template. The goal is to create a faithful replication of all Excel functionality in the web application.

## Prerequisites

1. Access to the CBAM Excel template
2. Access to the CBAM web application source code
3. PowerShell environment with ImportExcel module
4. Understanding of React, TypeScript, and the CBAM domain

## Step 1: Excel Template Analysis

### 1.1 Run the Excel Template Analyzer

Execute the `excel_template_analyzer.ps1` script to extract detailed information from the Excel template:

```powershell
.\excel_template_analyzer.ps1 -ExcelFile "CBAM communication template for installations.xlsx" -OutputDirectory "ExcelAnalysisOutput"
```

### 1.2 Review Extracted Information

For each worksheet, review:

- Column information (names, data types, sample values)
- Raw data
- Formulas
- Named ranges
- Data validations

### 1.3 Document Excel Functionality

Create a comprehensive document that describes:

1. **Documentation Sheets**:
   - Version history
   - Navigation instructions
   - User guidelines

2. **Reference Sheets**:
   - Code lists
   - Parameters
   - Translations

3. **Data Input Sheets**:
   - Installation data
   - Emissions data
   - Energy data
   - Process data
   - Purchased precursors data

4. **Summary Sheets**:
   - Calculations
   - Aggregations
   - Reports

5. **Calculation Sheets**:
   - Emission factors
   - Conversion factors
   - Calculation logic

## Step 2: Web Application Analysis

### 2.1 Map Excel Sheets to Web Components

Create a mapping between Excel sheets and web application components:

| Excel Sheet | Web Component | Component Path | Status |
|-------------|---------------|----------------|--------|
| A_InstData | InstallationDataForm | /components/installations/ | |
| B_Emissions | EmissionsForm | /components/emissions/ | |
| C_Energy | EnergyForm | /components/energy/ | |
| D_Processes | ProcessForm | /components/processes/ | |
| E_PurchasedPrecursors | PurchasedPrecursorsForm | /components/purchased-precursors/ | |
| F_Summary | SummaryReport | /components/summary/ | |

### 2.2 Document Web Application Structure

For each component, document:

- Data models
- State management
- API endpoints
- Validation logic
- Calculation logic

### 2.3 Document Web Application Calculations

Identify all calculations in the web application:

- Emission calculations
- Energy calculations
- Process calculations
- Summary calculations

## Step 3: Detailed Comparison

### 3.1 Use Comparison Templates

For each Excel sheet, complete the comparison template generated by the analyzer script:

1. **Field Comparison**: Compare Excel fields with web form fields
2. **Calculation Comparison**: Compare Excel formulas with web calculations
3. **Validation Comparison**: Compare Excel validations with web validations
4. **UI Comparison**: Compare Excel layout with web UI
5. **Data Flow Comparison**: Compare data flow in Excel with web application
6. **Integration Comparison**: Compare integration points

### 3.2 Identify Gaps

Document all gaps between Excel and web application:

1. **Missing Fields**: Fields present in Excel but not in web application
2. **Missing Calculations**: Calculations present in Excel but not in web application
3. **Missing Validations**: Validations present in Excel but not in web application
4. **Missing Workflows**: Workflows present in Excel but not in web application

### 3.3 Report Gaps

Create a comprehensive gaps report with:

- Priority level for each gap
- Impact assessment
- Estimated effort to implement

## Step 4: Implementation Plan

### 4.1 Define Implementation Tasks

For each identified gap, create implementation tasks:

1. **Field Implementation**: Add missing fields to web forms
2. **Calculation Implementation**: Add missing calculations to web application
3. **Validation Implementation**: Add missing validations to web forms
4. **Workflow Implementation**: Add missing workflows to web application

### 4.2 Create Timeline

Develop a realistic timeline for implementation:

- Phase 1: Critical gaps (4 weeks)
- Phase 2: Important gaps (3 weeks)
- Phase 3: Nice-to-have gaps (2 weeks)

### 4.3 Risk Management

Identify and mitigate risks:

- Data model changes
- Breaking changes to existing functionality
- Performance impacts
- User experience impacts

## Step 5: Implementation

### 5.1 Field Implementation

For each missing field:

1. Update data model:

```typescript
// Example: Adding a new field to InstallationData interface
interface InstallationData {
  // ... existing fields
  newField: string; // Add new field
}
```

2. Update React component:

```typescript
// Example: Adding a new field to InstallationDataForm component
const InstallationDataForm: React.FC = () => {
  const { data, updateData } = useInstallationData();
  
  return (
    <form>
      {/* ... existing fields */}
      <TextField
        label="New Field"
        value={data.newField || ''}
        onChange={(e) => updateData({ newField: e.target.value })}
      />
    </form>
  );
};
```

3. Update validation logic:

```typescript
// Example: Adding validation for new field
const validateInstallationData = (data: InstallationData): ValidationResult => {
  const errors: ValidationError[] = [];
  
  // ... existing validations
  
  if (!data.newField) {
    errors.push({ field: 'newField', message: 'New field is required' });
  }
  
  return { isValid: errors.length === 0, errors };
};
```

### 5.2 Calculation Implementation

For each missing calculation:

1. Update calculation engine:

```typescript
// Example: Adding a new calculation
const calculateNewValue = (data: InstallationData): number => {
  // Implement calculation logic from Excel
  const factor = getFactor('FactorName');
  return data.field1 * factor + data.field2;
};
```

2. Update React component to display calculation result:

```typescript
// Example: Displaying calculation result
const CalculationResult: React.FC<{ data: InstallationData }> = ({ data }) => {
  const result = calculateNewValue(data);
  
  return (
    <div>
      <h3>Calculation Result</h3>
      <p>{result.toFixed(2)}</p>
    </div>
  );
};
```

### 5.3 Validation Implementation

For each missing validation:

1. Update validation logic:

```typescript
// Example: Adding a complex validation
const validateComplexField = (value: string, context: ValidationContext): ValidationResult => {
  const errors: ValidationError[] = [];
  
  // Implement validation logic from Excel
  if (context.field1 && !value.startsWith(context.field1)) {
    errors.push({ field: 'complexField', message: 'Value must start with field1' });
  }
  
  return { isValid: errors.length === 0, errors };
};
```

2. Update React component to apply validation:

```typescript
// Example: Applying validation to form field
const ValidatedField: React.FC = () => {
  const { data, updateData, errors } = useFormData();
  
  return (
    <TextField
      label="Complex Field"
      value={data.complexField || ''}
      onChange={(e) => updateData({ complexField: e.target.value })}
      error={!!errors.find(e => e.field === 'complexField')}
      helperText={errors.find(e => e.field === 'complexField')?.message}
    />
  );
};
```

### 5.4 Workflow Implementation

For each missing workflow:

1. Update state management:

```typescript
// Example: Adding a new workflow state
interface WorkflowState {
  // ... existing states
  newWorkflowStep: 'pending' | 'in-progress' | 'completed';
}
```

2. Update React components to handle workflow:

```typescript
// Example: Implementing workflow step
const WorkflowStep: React.FC = () => {
  const { workflowState, updateWorkflowState } = useWorkflow();
  
  const handleComplete = () => {
    // Perform workflow actions
    updateWorkflowState({ newWorkflowStep: 'completed' });
  };
  
  return (
    <div>
      <h3>New Workflow Step</h3>
      <button onClick={handleComplete} disabled={workflowState.newWorkflowStep === 'completed'}>
        Complete Step
      </button>
    </div>
  );
};
```

## Step 6: Testing

### 6.1 Unit Testing

Create unit tests for all new functionality:

```typescript
// Example: Unit test for new calculation
describe('calculateNewValue', () => {
  it('should calculate correctly', () => {
    const data = { field1: 10, field2: 5 };
    const result = calculateNewValue(data);
    expect(result).toBe(15); // Assuming factor is 1
  });
});
```

### 6.2 Integration Testing

Create integration tests for component interactions:

```typescript
// Example: Integration test for form submission
describe('InstallationDataForm', () => {
  it('should submit data correctly', async () => {
    const { getByLabelText, getByText } = render(<InstallationDataForm />);
    
    fireEvent.change(getByLabelText('New Field'), { target: { value: 'Test Value' } });
    fireEvent.click(getByText('Submit'));
    
    await waitFor(() => {
      expect(mockSubmitFunction).toHaveBeenCalledWith(expect.objectContaining({
        newField: 'Test Value'
      }));
    });
  });
});
```

### 6.3 End-to-End Testing

Create end-to-end tests for complete workflows:

```typescript
// Example: E2E test for complete workflow
describe('Complete Workflow', () => {
  it('should complete workflow end-to-end', async () => {
    await page.goto('/installations');
    await page.fill('[data-testid="installation-id"]', '12345');
    await page.fill('[data-testid="installation-name"]', 'Test Installation');
    await page.click('[data-testid="save-button"]');
    await page.goto('/emissions');
    await page.fill('[data-testid="emission-value"]', '100');
    await page.click('[data-testid="save-button"]');
    await page.goto('/summary');
    await expect(page.locator('[data-testid="summary-value"]')).toContainText('100');
  });
});
```

### 6.4 Excel Comparison Testing

Create tests that compare web application results with Excel results:

```typescript
// Example: Excel comparison test
describe('Excel Comparison', () => {
  it('should match Excel calculation', () => {
    const inputData = { /* input data */ };
    const webResult = calculateEmission(inputData);
    const excelResult = getExcelCalculationResult(inputData);
    
    expect(webResult).toBeCloseTo(excelResult, 2); // Allow for small rounding differences
  });
});
```

## Step 7: Documentation

### 7.1 Update User Documentation

Update user guides to include:

- New fields
- New workflows
- Updated calculations

### 7.2 Update Technical Documentation

Update technical documentation to include:

- Updated data models
- New API endpoints
- Updated calculation logic

## Conclusion

By following this comprehensive guide, you can ensure that the CBAM web application faithfully replicates all functionality of the Excel template. The key is thorough documentation, systematic comparison, and comprehensive testing.

Remember to:

1. Document all Excel functionality thoroughly
2. Compare Excel functionality with web application systematically
3. Implement missing functionality carefully
4. Test all changes thoroughly
5. Update documentation to reflect changes

With this approach, you can create a web application that provides the same functionality as the Excel template while offering the benefits of a modern web interface.